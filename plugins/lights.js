const[e,t,i,r,s,n,o,l,d,a,g,c,h,f,m,E,I,_,u,R]=await Promise.all(["/lib/css.js","/lib/dom.js","/lib/drag.js","/lib/html.js","/lib/inter.js","/lib/misc.js","/lib/nodes.js","/lib/svg.js","/adminMap.js","/colours.js","/folders.js","/keys.js","/language.js","/map_fns.js","/map_tokens.js","/plugins.js","/rpc.js","/shared.js","/symbols.js","/windows.js"].map(include));if(I.isAdmin){let L=0;class N extends m.Lighting{id;constructor(e){const{lightColours:t=[],lightStages:i=[],lightTimings:r=[]}=j.get(e)?.data??{};super(0,0,5,5,t,i,r),this.id=-e}transfer(){return this}}class p extends g.DraggableItem{#e=null;#t;#i;constructor(e,i,r){super(e,i,r,S),t.amendNode(this.image,{src:u.lightGridStr,width:"20px",height:"20px"}),w.set(i,this),this.#t=d.dragLighting.register(this.#i=new N(i)),t.amendNode(this.nameElem,{onauxclick:e=>{1===e.button&&this.#r()}})}#r(){const e=m.selected.token;if(e){const{lightColours:t,lightStages:i,lightTimings:r}=this.#i;f.doTokenSet({id:e.id,lightColours:_.cloneObject(t),lightStages:_.cloneObject(i),lightTimings:_.cloneObject(r)})}}show(){if(this.#e)this.#e.focus();else{const e=l.polygon({points:"0,0 10,0 10,10 0,10"}),i=m.definitions.addLighting(e,this.#i,5/this.#i.lightStages.reduce(((e,t)=>e+t),0)),s="plugin-light_"+L++,n=this;t.amendNode(R.shell,this.#e=R.windows({"window-title":this.name,"window-icon":u.lightGridStr,resizable:!0,style:"--window-width: 50%; --window-height: 50%",onremove:()=>{this.#e=null}},[r.button({style:"position: absolute",onclick:function(){n.#r(),this.blur()}},T.APPLY_LIGHT),l.svg({viewBox:"0 0 10 10"},[l.rect({width:5,height:10,fill:"#fff"}),l.rect({x:5,width:5,height:10,fill:"#000"}),t.amendNode(i,{id:s}),t.amendNode(e,{fill:`url(#${s})`})])]))}}ondragstart(e){super.ondragstart(e),e.defaultPrevented||d.dragLighting.set(e,this.#t)}delete(){this.#e?.remove(),d.dragLighting.deregister(this.#t)}}class A extends g.DragFolder{constructor(e,t,i,r){super(e,t,i,r,S,P)}removeItem(e){const t=super.removeItem(e);return w.delete(t),t}ondragover(e){super.ondragover(e),K(e)}ondragenter(e){super.ondragenter(e),d.dragLighting.is(e)&&(t.amendNode(this[o.node],{class:["dragover"]}),t.amendNode(this.root[o.node],{class:["folderDragging"]}))}ondrop(e){if(super.ondrop(e),d.dragLighting.is(e)){const{id:t,lightColours:i,lightStages:r,lightTimings:s}=d.dragLighting.get(e);t>=0&&z(i,r,s,this)}}}let O=0;const T=h.makeLangPack({APPLY_LIGHT:"Apply Light to Selected Token",COPY_LIGHT:"Copy Light from Selected Token",ERROR_FOLDER_NOT_EMPTY:"Cannot remove a non-empty folder",ERROR_INVALID_FOLDER:"Invalid Folder",ERROR_INVALID_ITEM:"Invalid Item",ERROR_INVALID_PATH:"Invalid Path",MENU_TITLE:"Light Profiles",NAME_EXISTS:"Light Profile Exists",NAME_EXISTS_LONG:"A Light Profile with that name already exists",NAME_INVALID:"Invalid Name",NAME_INVALID_LONG:"Light Profile names cannot contain the '/' (slash) character",NEW_NAME:"Please enter a name for this Light Profile",NEW_NAME_TITLE:"Light Profile Name",REMOVE_LIGHT:"Remove Light from Selected Token"}),S=new i.DragTransfer("pluginlightitem"),P=new i.DragTransfer("pluginlightfolder"),b=E.pluginName(import.meta),j=new Map,w=new Map,D={user:!1,data:{folders:{},items:{}}},v=e=>{if(!(e instanceof Object&&e.folders instanceof Object&&e.items instanceof Object))return!1;for(const t in e.items)if(!n.isInt(e.items[t],0))return!1;for(const t in e.folders)if(!v(e.folders[t]))return!1;return!0},M=e=>{if(e instanceof Object&&e.lightColours instanceof Array&&e.lightStages instanceof Array&&e.lightTimings instanceof Array&&e.lightColours.length===e.lightStages.length){for(const t of e.lightColours){if(!(t instanceof Array)||t.length!==e.lightTimings.length)return!1;for(const e of t){if(!(e instanceof Object&&n.isInt(e.r,0,255)&&n.isInt(e.g,0,255)&&n.isInt(e.b,0,255)&&n.isInt(e.a,0,255)))return!1;a.Colour.from(e)}}for(const t of e.lightStages)if(!n.isInt(t,0))return!1;for(const t of e.lightTimings)if(!n.isInt(t,0))return!1;return!0}return!1},V=e=>{if(!(e instanceof Object&&e[""]instanceof Object&&!1===e[""].user&&v(e[""].data)))return D;for(const t in e)if(""!==t){const i=parseInt(t);!isNaN(i)&&e[t]instanceof Object&&!e[t].user&&M(e[t].data)&&(j.set(i,e[t]),i>O&&(O=i))}return e[""]},y=s.Subscription.bind(1),G=s.Subscription.bind(1),k=s.Subscription.bind(1),H=s.Subscription.bind(1),C=s.Subscription.bind(1),F=s.Subscription.bind(1),X=new s.Subscription((()=>{})),x=V(E.getSettings(b)),W=(e,t=x.data)=>{const i=e.split("/"),r=i.pop()??"";for(const e of i)if(e&&!(t=t.folders[e]))return[null,r];return[t,r]},Y=e=>{const t=e.split("/");e="";for(const i of t)i&&(e+=`/${i}`);return e},U=new g.Root(x.data,T.MENU_TITLE,{list:()=>Promise.resolve(x.data),createFolder:e=>{const[t,i]=W(e);return t?t.folders[i]?(I.handleError(T.NAME_EXISTS_LONG),Promise.reject(T.NAME_EXISTS_LONG)):(t.folders[i]={folders:{},items:{}},I.rpc.pluginSetting(b,{"":x},[]),Promise.resolve(e)):(I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH))},move:(e,t)=>{const[i,r]=W(e),[s,n]=W(t);if(!i||!s)return I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH);const o=i.items[r];return void 0===o?(I.handleError(T.ERROR_INVALID_ITEM),Promise.reject(T.ERROR_INVALID_ITEM)):s.items[n]?(I.handleError(T.NAME_EXISTS_LONG),Promise.reject(T.NAME_EXISTS_LONG)):(delete i.items[r],s.items[n]=o,I.rpc.pluginSetting(b,{"":x},[]),Promise.resolve(t))},moveFolder:(e,t)=>{if(e=Y(e),(t=Y(t)).startsWith(e))return I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH);const[i,r]=W(e),[s,n]=W(t);return i&&s?i.folders[r]?s.folders[n]?(I.handleError(T.NAME_EXISTS_LONG),Promise.reject(T.NAME_EXISTS_LONG)):(s.folders[n]=i.folders[r],delete i.folders[r],I.rpc.pluginSetting(b,{"":x},[]),Promise.resolve(t)):(I.handleError(T.ERROR_INVALID_FOLDER),Promise.reject(T.ERROR_INVALID_FOLDER)):(I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH))},remove:e=>{const[t,i]=W(e);if(!t)return I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH);const r=t.items[i];return void 0===r?(I.handleError(T.ERROR_INVALID_ITEM),Promise.reject(T.ERROR_INVALID_ITEM)):(j.delete(r),delete t.items[i],I.rpc.pluginSetting(b,{"":x},[r+""]),Promise.resolve())},removeFolder:e=>{const[t,i]=W(Y(e));if(!t)return I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH);const r=t.folders[i];return r?0!==Object.keys(r.folders).length||0!==Object.keys(r.items).length?(I.handleError(T.ERROR_FOLDER_NOT_EMPTY),Promise.reject(T.ERROR_FOLDER_NOT_EMPTY)):(delete t.folders[i],I.rpc.pluginSetting(b,{"":x},[]),Promise.resolve()):(I.handleError(T.ERROR_INVALID_FOLDER),Promise.reject(T.ERROR_INVALID_FOLDER))},copy:(e,t)=>{const[i,r]=W(t);return i?i.items[r]?(I.handleError(T.NAME_EXISTS_LONG),Promise.reject(T.NAME_EXISTS_LONG)):(i.items[r]=e,I.rpc.pluginSetting(b,{"":x},[]),Promise.resolve({id:e,path:t})):(I.handleError(T.ERROR_INVALID_PATH),Promise.reject(T.ERROR_INVALID_PATH))},waitAdded:()=>y[0],waitMoved:()=>G[0],waitRemoved:()=>k[0],waitCopied:()=>X,waitFolderAdded:()=>H[0],waitFolderMoved:()=>C[0],waitFolderRemoved:()=>F[0]},p,A),$=(e,t,i,r)=>{for(const s in e.folders){const n=i+s+"/";t.folders[s]?$(e.folders[s],t.folders[s],n,r):r[n]=-1}for(const s in t.folders)e.folders[s]||(r[i+s+"/"]=0);for(const s in e.items)t.items[s]?e.items[s]!==t.items[s]&&(r[""]=1):r[i+s]=-e.items[s];for(const s in t.items)e.items[s]?e.items[s]!==t.items[s]&&(r[""]=1):r[i+s]=t.items[s]},K=i.setDragEffect({copy:[d.dragLighting]}),z=(e,t,i,r)=>{R.shell.prompt(T.NEW_NAME_TITLE,T.NEW_NAME,"",u.lightGridStr).then((s=>{if(s)if(s.includes("/"))R.shell.alert(T.NAME_INVALID,T.NAME_INVALID_LONG);else if(r.children.has(s))R.shell.alert(T.NAME_EXISTS,T.NAME_EXISTS_LONG);else{const n={user:!1,data:{lightColours:e,lightStages:t,lightTimings:i}},[o]=W(r.getPath()+"/");o&&(j.set(o.items[s]=++O,n),r.addItem(O,s),I.rpc.pluginSetting(b,{"":x,[O]:n},[]))}}))},B=()=>{const e=m.selected.token;e&&f.doTokenSet({id:e.id,lightColours:[],lightStages:[],lightTimings:[]})},q=r.button({onclick:function(){this.blur(),B()}},T.REMOVE_LIGHT),[J,Q]=c.registerKeyEvent("lights-remove",T.REMOVE_LIGHT,"",B),Z=()=>{const e=m.selected.token;if(e){const{lightColours:t,lightStages:i,lightTimings:r}=e;i.length&&r.length&&z(_.cloneObject(t),_.cloneObject(i),_.cloneObject(r),U.folder)}},ee=r.button({onclick:function(){this.blur(),Z()}},T.COPY_LIGHT),[te,ie]=c.registerKeyEvent("lights-copy",T.COPY_LIGHT,"",void 0,Z),re=()=>{const e=m.selected.token;let i=!0;if(e){const{lightStages:t,lightTimings:r}=e;t.length&&r.length&&(i=!1),te(),J()}else ie(),Q();t.amendNode(ee,{disabled:i}),t.amendNode(q,{disabled:i})},se=e.id();e.add(`#${se}`,{" ul":{"padding-left":"1em","list-style":"none"},">div>ul":{padding:0}}),m.tokenSelectedReceive(re),I.combined.waitTokenSet().when(re),U.windowIcon=u.lightGridStr,E.addPlugin("lights",{menuItem:{fn:[T.MENU_TITLE,r.div({id:se},[ee,q,U[o.node]]),!0,u.lightGridStr]}}),I.rpc.waitPluginSetting().when((({id:e,setting:t,removing:i})=>{if(e===b){for(const e of i){const t=parseInt(e);isNaN(t)||j.delete(t)}for(const e in t)if(""===e){if(!v(t[""].data))continue;const e={};$(x.data,t[""].data,"/",e);const i=Object.keys(e);let r=!1;if(e[""]||i.length>2)r=!0;else if(1===i.length)e[i[0]]<0?i[0].endsWith("/")?F[1](i[0]):k[1](i[0]):i[0].endsWith("/")?H[1](i[0]):y[1]([{id:e[i[0]],name:i[0]}]);else if(2===i.length)if(i[0].endsWith("/")===i[1].endsWith("/"))if(i[0].endsWith("/")){const s={};e[i[0]]<0?$(W(i[0])[0],W(i[1],t[""].data)[0],"/",s):$(W(i[0],t[""].data)[0],W(i[1])[0],"/",s),0===Object.keys(s).length?C[1](e[i[0]]<0?{from:i[0],to:i[1]}:{from:i[1],to:i[0]}):r=!0}else e[i[0]]+e[i[1]]===0?G[1](e[i[0]]<0?{from:i[0],to:i[1]}:{from:i[1],to:i[0]}):r=!0;else r=!0;r&&U.setRoot(t[""].data),x.data=t[""].data}else{const i=parseInt(e),r=t[e];!isNaN(i)&&M(r.data)&&j.set(i,r)}}}))}